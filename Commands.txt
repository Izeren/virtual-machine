Код начинается с Data Section, в этом разделе можно описать Int и Str(Ascii строка) переменные. Общий размер DataSection не должен превышать 256*4 байта (Int занимает 4 байта, Str занимает (4 - strlen % 4) * 4 байт так как хранится длина строки, затем сама строка, добитая нулями до кратности 4-м)

STOP                      - Команда остановки виртуальной машины
PRINT       Str           - Выводит строку на экран (интерпретирует аргумент как последовательность ASCII байт до вхождения '\0')
PRINT_INT   Int           - Интерпретирует 4 байта по адресу как целое число и выводит на экран
READ_INT                  - Считывает число введенное пользователем и помещает его на стек
MV          To From       - Помещает записывает целое значение по адресу From в адрес To 
JUMP        Label         - Записывает в значение IP адрес Label
IF_EQ       L1 L2         - Проверяет совпадение значений по адресам L1 и L2 записывает результат в LL
CJUMP       Label         - Если LL == 1, делает JUMP на Label
ADD         To From       - Добавляет значение по адресу From к значению по адресу To и сохраняет результат в To
SUB         To From       - Вычитает значение по адресу From из значения по адресу To и сохраняет результат в To
PUSH        From          - Помещает значение по адресу From на стек
POP         To            - Извлекает значение из стека и кладет его по адресу To
GET         Offset To     - Копирует значение из стека со сдвигом offset (0 - верхний) по адресу To
PUSH_IP     Offset(from)  - Кладет значение IP + 4 * offset на стек (Используется в макросе CALL)
LS_INC      Offset(from)  - Увеличивает значение LS на offset * 4
LS_DEC      Offset(from)  - Уменьшает значение LS на offset * 4 (Используется для очистки стека в макросе RET)
MJUMP       Var           - Совершает Jump по адресу, записанному в переменной Var (Используется для возврата из функции)

Первые 20 байт зарезервированы под IP(Instruction Pointer), LL(Last Logical), LS(Last on Stack), _TMP_RET(для временного хранения адреса возврата), _TMP_ARGC (Для временного хранения количества аргументов, используется в макросе RET)

В данном ассемблере допускается использование ULong чисел вместо адресов переменных во всех операциях, которые должны принимать адрес переменной, при условии, что переменная по этому адресу используется только для чтения (например, нельзя писать ADD 3 4 или ADD 3 TMP)

Для безусловных и условных прыжков предусмотрены метки. Метки можно использовать только в секции кода, они предваряют операцию и берутся в кавычки, например "label1" ADD TMP 3, важно, что в командах CALL, JUMP, CJUMP, MJUMP, метки пишутся БЕЗ КАВЫЧЕК (JUMP label1), метки должны обладать свойством уникальности (прыгать из разных мест на одну метку, разумеется можно)

Все функции объявляются после команды STOP и до ключевого слова STACK(оно не имеет смысла для VM и вырезается ассемблером как и слово START, которое разграничивает DataSection и CodeSection)

Начало функции обозначается меткой. Возврат из функции - макросом RET

Чтобы вызвать функцию, нужно положить на стек все ее аргументы, далее вызвать макрос CALL function 2, в качестве аргументов макроса выступает метка начала функции и количество аргументов переданных на стек. Этот макрос помещает на стек количество аргументов и адрес возврата. Аргументы из функции видны по команде GET 2 TMP, GET 3 TMP и т. д. Перед вызовом макроса RET функция должна вернуть стек в состояние, в котором он находился в момент перехода по метке function (для корректной работы RET)

Здесь есть 3 примера кода: 
  -- fib.asm - вычисление числа Фибоначчи циклом 
  -- fib_rec.asm - вычисление числа Фибоначчи при помощи рекурсии
  -- sum.asm - пример простой программы складывающей 2 числа с использованием функции